---
title: "Biomass_AmpEff_variation_func"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r dependencies}
library(here)
library(tidyverse)
library(binr)
library(lattice)
library(viridisLite)
```

The goal of following function (TechDrops.vs.CountsAmps) is to see how the frequency of dropouts among technical reps varies as a function of amplification efficiency and original biomass or count. 

Single argument is an Input dataframe with the following columns: 
- tech_1, tech_2, and tech_3 with read counts from each technical replicate
- abundance, with manual counts or other information on original template amount 
- amp_ef, with amplication efficiency for each asv-sample (each row, essentially)

```{r tech variability as function of amp efficiency and biomass}
TechDrops.vs.CountsAmps <- function(input_df){
  
total_binned_df <- total_binned_df <- data.frame(input_df,abundance_bin=cut(input_df$abundance,unique(as.numeric(quantile(input_df$abundance, probs = seq(0, 1, 1/8)))),include.lowest=TRUE),  ampef_bin = cut(input_df$amp_ef,unique(as.numeric(quantile(input_df$amp_ef, probs = seq(0, 1, 1/8)))),include.lowest=TRUE))  # sort abundance and amp efficiency into quantiles with all input data

unique_bins <- unique(total_binned_df[,c("abundance_bin","ampef_bin" )]) # all unique amp bin and abundance bin combinations

list <- replicate(length(unique_bins[,1]), rep(NA, length=nrow(total_binned_df)), simplify = FALSE) # list of empty vectors (length of input dataframe), one vector for all the row indices corresponding to an unique amp&abundance bin combination

propdrops <- unique_bins %>% mutate(dropout_proportion = rep(NA, length(unique_bins[,1]))) # where proportion of dropouts will go for each unique amp&abundance bin combination

for(i in 1:length(unique_bins[,1])){
  bin <- as.numeric(unique_bins[i,]) # get vector of numeric factor levels of that abundance/amp bin (so c([1,3], [0.1,0.3]) would be c(1,1))
  
  # Gets index values in input dataframe corresponding to a the numeric factor levels for given abundance/amp bin 
  bin_levels_list <- lapply(total_binned_df[,c('abundance_bin','ampef_bin')], as.numeric)
  bin_indices <- which(bin_levels_list$abundance_bin == bin[1] & bin_levels_list$ampef_bin == bin[2])
  
  specific_bin_df <- total_binned_df[bin_indices,] # subset data to only include given abundance/amp bin, get prop of dropouts
  
  dropouts <- c(which(specific_bin_df$tech_1 == 0),
              which(specific_bin_df$tech_2 == 0),
              which(specific_bin_df$tech_3 == 0))
  propdrops[i,3] <- length(unique(dropouts)) / nrow(specific_bin_df)
  
}

# just adding numerical factor levels to the bin factor levels
outputdf <- cbind(propdrops, unique(cbind(bin_levels_list$abundance_bin, bin_levels_list$ampef_bin)))

# plot 

print(levelplot(dropout_proportion ~ `2`*`1`, # "2" is amp, "1" is abundance
          scales=list(x= list(at=sort(unique(outputdf$`2`))),
                      y= list(at=sort(unique(outputdf$`1`)))),
          colorkey= list(title= "Proportion of Dropouts"),
          data=outputdf,
          xlab="amplification efficiency bins",
          ylab = "abundance bins",
          main="",
          col.regions = viridis(100)))

return(outputdf)
}

# should relable w/ actual bins, and figure out way to make more than 4 bins (how many hm) 
```

```{r run function w dataset}
CalCofi_mock_complete <- read.csv(here("special_issue_manuscript","Data", "complete_cal_props_wide.csv"))

CalCofi_mock_complete <- CalCofi_mock_complete %>% rename(c("abundance" = larval_counts, "tech_1" = X1, "tech_2" = X2, "tech_3" = X3))



output <- TechDrops.vs.CountsAmps(input_df = CalCofi_mock_complete)
```

