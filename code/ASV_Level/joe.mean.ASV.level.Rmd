---
title: "helen.ASV.level.var"
author: "Helen Casendino"
date: "8/05/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
```{r dependencies, include=FALSE}
library(tidyverse)
library(gridExtra)
library(stringi)
```

# Part A. ASV Variation within Technical Replicates

## Description: 

  1) Starting with triplicate PCR reads that have seriously low reads excluded, I'll get a standard deviation across PCR reps for each Hash. Hashes in different bio reps are kept separate. 
  2) Then, I'll loop through different proportion cutoffs (averaging proportions across PCR reps for each hash), each time calculating the LOGNORMAL mean of all of the standard deviations (across bio reps, etc.)

```{r read in clean triplicate data}
trip.proportion.reads <- read.csv('../../data/PCR.proportions.clean.csv')
```

```{r standard deviation of each Hash}
SD.across.rows <- function(df, col.numbers){ # here, col.numbers corresponds to 3 PCR columns
  df$StanDev <- NA
  values.only <- df[,col.numbers]
  df$StanDev <- apply(values.only, MARGIN = 1, sd, na.rm=TRUE) #joe added na.rm=TRUE

  return(df)
}

SD.tech.output <- SD.across.rows(trip.proportion.reads, c(4:6))
mean(SD.tech.output$StanDev)
```

In an attempt to trouble shoot getting means across replicates lets see if there are double-hashes.
Shouldn't table(hash.rep.taly$n) only be "1s"? 

```{r}
hash.rep.tally <- trip.proportion.reads %>%
  unite(bio, Hash, col=ID, sep='.', remove=TRUE) %>%
  group_by(ID) %>%
  add_tally()

table(hash.rep.tally$n)

```

```{r get output, check for lognormality}
# output<- SDcutoffs(trip.proportion.reads,seq(0, 0.0003, 0.00001))

# check the lognormal distributions for SDs of each cutoff...a few are a little asymmetrical (also loop crashes sometimes depending on how large cutoff sequence so beware)
#for(i in 1:length(seq(0, 0.0003, 0.00001))){
#  hist(output[[2]][,i])
#}
```

So the SD lognormal distributions look pretty good, but some are slightly asymmetrical. Now let's plot to see how average SD between PCR replicates changed between proportion cutoffs.

```{r Plotting output}
# 1) Plot mean variability vs. cutoff
# SDvsProp.plot <-  ggplot() +  theme_minimal() + geom_line(mapping = aes(x = output[[1]][,1], y = output[[1]][,2]), size = .5, color = "red3") + theme(legend.position = "none") + theme(axis.title.y = element_text(color = "red3")) + scale_y_continuous(name = "Mean SD Across PCRs") + xlab("Proportion Cutoff") 
# 
# # 2) Plot percent of unique hashes chopped vs. cutoff
# ChoppedvsProp.plot <-  ggplot() +  theme_minimal() + geom_line(mapping = aes(x = output[[1]][,1], y = output[[1]][,3]*100), size = .5, color = "darkmagenta") + theme(legend.position = "none") + theme(axis.title.y = element_text(color = "darkmagenta")) + scale_y_continuous(name = "% Unique Hashes Removed") + xlab("Proportion Cutoff")
# 
# grid.arrange(SDvsProp.plot,ChoppedvsProp.plot, nrow=1)
```

# Part B. ASV Variation within Biological Replicates (also only triplicates)

## Description:
  - Main goal of code below is to get distribution & mean of ASV variation within Biological and PCR replicates combined, and subtract PCR variation to isolate bio variation
  - The code below creates a nested df where each table belongs to a certain sample (eg, PO20170311)
  - Each table has columns corresponding to every bottle/PCR combination (A.1, B.1, C.2, C.3, etc) and rows corresponding to each ASV found. Values = proportions within a specific bottle
  -Take the standard deviations of each ASV's proportions (across different bio.PCRs)
  - End up with a single distribution of SDs for each distinct sampling event

```{r Data Organization: dataset specific}
long.props <- trip.proportion.reads %>% 
  mutate(sample = gsub('.{1}$', '', bio)) %>% 
  mutate(bottle = stri_sub(bio,-1)) %>% 
  pivot_longer(cols = c(PCR1_prop,PCR2_prop,PCR3_prop), names_to = "PCR", values_to = "Proportion")

get.PCRn <- long.props %>% 
  mutate("PCRn" = stri_sub(PCR,4,-6)) %>% 
  # separate(sample, into = c('sample', 'foo'), sep=8) %>% # cut off the day lables on the 2017 samples 
  select(-c(bio, PCR)) %>%
  unite(sample, bottle, col = biorep, sep = ".", remove=FALSE) %>% 
  group_by(biorep, Hash) %>%
  # add_tally()
  summarise(meanprop=(sum(Proportion))/3)

# bio.means <- get.PCRn %>%
#   group_by(biorep, Hash) %>%
#   summarise(meanprop=sum(Proportion)/n)

nesttest <- nest(get.PCRn, data=!biorep)

# do all the proportion add up to 1? they do maybe? wierd behavior for testvec
j <- 1
testvec <- c(length=length(nesttest$data))

for (i in nesttest$data){
  print(sum(i$meanprop))
  testvec[j] <- sum(i$meanprop)
  j <- j+1
}

testdf <- as.data.frame(testvec)
print(unique(testvec))
##############################################################################

get.PCRn <-get.PCRn %>%
  separate(col=biorep, into=c('sample','bio'), sep='[.]', remove=TRUE)

nested.props <- get.PCRn %>% 
  nest(data = c(bio, Hash, meanprop))
```

Now I want to convert each sample's df to have columns for each **biological replicate**

```{r Widen data so that bio.PCRs are columns}
for(i in 1:length(nested.props$sample)) {
  
  nested.props$data[[i]] <- nested.props$data[[i]] %>% 
    group_by(bio, Hash) %>% 
    pivot_wider(names_from = bio, values_from=meanprop, values_fill = 0) 
    
    print(i)
}
```

Make and run function that gets SDs across bio reps for each ASV within a sample. I'm rewrote this because
I couldn't get Helen's function to work with the new data format. 

```{r}
# unnest to make taking SD across rows easier 
bio.prop <- unnest(nested.props, cols=c(data))

# apply sd to all columns 3 and over
bio.prop$StanDev <- apply(bio.prop[3:ncol(bio.prop)], MARGIN = 1, sd, na.rm=TRUE)

hist(log(bio.prop$StanDev), breaks=40)
hist(log(SD.tech.output$StanDev), breaks=40)

mean(log(SD.tech.output$StanDev))
mean(log(bio.prop$StanDev))

# for now lets just see what the standard deviations are that are not NA 
bio.prop <- bio.prop %>%
  filter(!is.na(StanDev))

######## need to make two SD on the same plot 
hist.df <- data.frame(StanDev = c(log(SD.tech.output$StanDev), log(bio.prop$StanDev)), 
                  Division = c(rep(x='tech', times=length(SD.tech.output$StanDev)),
                               rep(x='bottle', times=length(bio.prop$StanDev))))

ggplot(hist.df, aes(x=StanDev)) + 
    geom_histogram(data=subset(hist.df, Division == 'tech'),fill = "red", alpha = 0.4, bins=60) +
    geom_histogram(data=subset(hist.df, Division == 'bottle'),fill = "blue", alpha = 0.4, bins=60) +
    labs(y="count", x = "log(Standard Deviation)") +
    geom_vline(aes(xintercept=mean(log(SD.tech.output$StanDev))), color="red", size=2) +
    geom_vline(aes(xintercept=mean(log(bio.prop$StanDev))), color="blue", size=2)


mean(bio.prop$StanDev)
mean(log(bio.prop$StanDev))
boxplot(log(bio.prop$StanDev))

```
```{r}

```

