---
title: "Community Level PCR & Bottle Variation - Bray Curtis"
author: "Helen Casendino, Joe Duprey"
date: "9/28/2021"
output: html_document
---
  
```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r dependencies, include = FALSE}
library(tidyverse)
library(vegan)
library(stringi)
```

This code functions similarly to centroid.comm.var.Rmd, in that it creates distributions of variability among technical (PCR) and biological (bottle) replicates at the community level, using the OA data with triplicate PCRs. It functions differently in a few ways: 
     
      1) instead of calculating the distance to the centroid for each bottle or sampling event, it harvests all bray-curtis pairwise distances from the vegdist() output
      2) For the biological replicate level (distance b/w bottles within sampling event), there is NO AVERAGING ACROSS PCRs...ie, we are collecting pairwise BC distances among A.1,A.2,A.3,B.1,B.2, etc.
      3) To avoid tabulating intra-bottle PCR variation when looking at the bio replicate level, we will only harvest pairwise distances between communities in *different* bottles...ie, take the pairwise distance between A.1 and B.1,B.2,B.3, but not between A.1 and A.2,A.3
      
## Step 1: Read in the data

```{r load in data}
long_props <- read.csv("../../data/long_PCR_props.csv")
```
      
## Step 2: PCR Variation

We create a function that computes the pairwise Bray-Curtis dissimilarities among technical replicates within each biological sample, stores all obtained values in a numeric vector, and plots those values in histogram. Our function allows the user to specify which sequence runs should be analyzed (by default, all will be used), hence the seq_runs vector parameter. Below we apply our function to the OA data.

```{r create and run find_PCR_BCDs function}
# Computes pairwise Bray-Curtis dissimilarities among technical replicates from 
# each biological sample. Returns a vector of those values.
# Args:
#   df: A data frame with columns for bio, tech, hash, prop, and seq_run.
#   seq_runs: A vector containing the numbers of the seq runs to be analyzed.
find_PCR_BCDs <- function(df, seq_runs = unique(df$seq_run)) {  # Includes all seq runs by default
  df <- df %>% 
    filter(seq_run %in% seq_runs) %>% 
    select(bio, tech, hash, prop)
  
  bottles <- unique(df$bio)
  bcds_upper_bound <- choose(max(df$tech), 2) * length(bottles)
  bcds <- rep(NA, bcds_upper_bound)  # Vector to store BCDs
  i <- 1
  
  # Iterate over each bottle and calculate BCDs among PCRs
  for (bottle in bottles) {
    # Data wrangling in preparation for the vegdist function
    bottle_data <- df %>% 
      filter(bio == bottle) %>% 
      pivot_wider(names_from = tech, values_from = prop, values_fill = 0) %>% 
      select(matches("\\d{1, }"))  # Columns that have numbers as names (i.e., represent PCRs)
    flipped_bottle_data <- t(bottle_data)
    num_PCRs <- nrow(flipped_bottle_data)
    dis <- vegdist(flipped_bottle_data)
    bcds[i:(i + num_PCRs - 1)] <- as.vector(dis)
    i <- i + num_PCRs
  }
  
  bcds <- as.numeric(na.omit(bcds))
  
  # Sanity check
  print("Bray-Curtis Dissimilarities:")
  print(bcds)
  print(paste("Mean BCD value:", mean(bcds), sep = " "))
  
  # Plot
  hist(
    bcds,
    col = viridis::plasma(3, 0.4, 0.7),
    main = "PCR Variation",
    xlab = "Pairwise Bray-Curtis Dissimilarities"
  )

  bcds
}

# Run the function with our data
# TODO : FIGURE OUT WHAT'S UP WITH 5 AND 6 AND ALSO DIFFERNECES BETWEEN SEQ RUNS
PCR_output <- find_PCR_BCDs(long_props, 1:4)
```

## Step 3: Bottle Variation

As a reminder, we are *not* averaging across PCRs.

```{r helper function for data wrangling}
# A helper function for data wrangling. Prepares a data frame for the
# find_bottle_BCDs function by nesting the data by site.
# Args:
#   df: A data frame with columns for bio, tech, hash, prop
nest_data <- function(df) {
  nested_data_by_site <- df %>% 
    ungroup() %>%  # TODO : DELETE LINE ONCE I'M DONE TESTING
    mutate(site = gsub(".{1}$", "", bio)) %>%  # Separate site and bottle info from each other
    mutate(bottle = stri_sub(bio, -1)) %>% 
    select(site, bottle, tech, hash, prop) %>% 
    unite(bottle, tech, col = "bio.PCR", sep = ".") %>%  # Combine to get A.1, A.2, etc.
    arrange(site, bio.PCR, hash) %>% 
    nest(data = c(bio.PCR, hash, prop))
  
  # At this point, nested_data_by_site has the following structure:
  #   site       data           
  #   <chr>      <list>              
  # 1 PO20170311 <tibble [1,824 × 3]>
  # 2 LL20170311 <tibble [1,670 × 3]>  
  
  # Each element of site_data looks like this:
  #   bio.PCR hash                                      prop
  #   <chr>   <chr>                                    <dbl>
  # 1 F.1     11a112ced1c85e620f6d97d82281a1bb58614e67 0.262
  # 2 A.3     11a112ced1c85e620f6d97d82281a1bb58614e67 0.363
  
  # Change columns to: hash, A.1, A.2, A.3, B.1, B.2, etc.
  for (i in 1:length(nested_data_by_site$data)) {
    nested_data_by_site$data[[i]] <- nested_data_by_site$data[[i]] %>%
      pivot_wider(names_from = bio.PCR, values_from = prop, values_fill = 0)
  }
  
  # Note: At this point, each item in the data column is a data frame. Within
  # each of those data frames, columns correspond to bio.PCR combos (in order!)
  # and rows correspond to individual hashes. This is highly relevant for our 
  # find_bottle_BCDs function!
  
  nested_data_by_site
}
```


```{r create & run function to calculate BCDs by sampling event; Plot}
# Computes pairwise Bray-Curtis dissimilarities across different biological
# replicates (but not among PCRs from the same bottle). Returns a vector of
# those values and a histogram.
# Args:
#   df: A data frame with columns for bio, tech, hash, prop, and seq_run.
find_bottle_BCDs <- function(df) {
  # Find a length for bcds that is certain to contain all calculated values. We
  # do this by finding the maximum number of replicates from any individual site.
  temp <- df %>%
    mutate(site = gsub(".{1}$", "", bio)) %>%  # Separate site and bottle info from each other
    mutate(bottle = stri_sub(bio, -1)) %>% 
    select(site, bottle, tech) %>% 
    group_by(site) %>% 
    unique() %>%  # Get rid of duplicate rows bc we don't care about the number of hashes
    mutate(n = n())  # Number of replicates for that site
  
  max_replicates <- max(temp$n)
  df <- nest_data(df)  # Data wrangling using helper function
  
  # Notes:
  # a) max_replicates ^ 2 is the max size of any BCD matrix generated from a
  # single site
  # b) We multiply by 0.5 bc at least half the values from each dis_mat matrix
  # will be removed (to eliminate duplicates and intra-bottle comparisons)
  bcds <- rep(NA, ceiling((max_replicates ^ 2) * 0.5 * length(df$site)))
  i <- 1
  
  for (j in 1:length(df$site)) {
    event <- df$data[[j]]  # A data frame corresponding to one sampling event
    sub_tib <- event %>% select(!c(hash))
    flip_tib <- t(sub_tib)
    dis <- vegdist(flip_tib)
    dis_mat <- as.matrix(dis)

    # Removes all cells corresponding to BCDs within the same bottle by using
    # row and column names. Also removes all the duplicates below the diagonal.
    for (col_num in 1:ncol(dis_mat)) {
      # Extracting the first letter (A, B, C, etc) from the column's name
      col_letter <- substr(colnames(dis_mat)[col_num], 1, 1)
      for (row_num in 1:nrow(dis_mat)) {
        # Extracting the first letter (A, B, C, etc) from the row's name
        row_letter <- substr(rownames(dis_mat)[row_num], 1, 1)
        if (! col_letter > row_letter) {
          dis_mat[row_num, col_num] <- NA
        }
      }
    }

    bcd_vector <- na.omit(as.vector(dis_mat))  # All BCDs for that sampling event as vector
    len <- length(bcd_vector)
    if (len > 0) {
      bcds[i:(i + len - 1)] <- bcd_vector  # Add the BCD values to our long vector
      i <- i + len  # Update index
    }
  }

  bcds <- as.numeric(na.omit(bcds))
  
  # Sanity check
  print("Bray-Curtis Dissimilarities:")
  print(bcds)
  print(paste("Mean BCD value:", mean(bcds), sep = " "))
  
  # Plot
  hist(
    as.numeric(bcds[-1]),
    col = viridis::viridis(3, 0.4, 0.7),
    main = "Bottle Variation",
    xlab = "Bray-Curtis Pairwise Distances"
  )

  bcds
}

bottle_output <- find_bottle_BCDs(long_props)
```

      
