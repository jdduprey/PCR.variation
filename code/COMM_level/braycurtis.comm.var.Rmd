---
title: "Community Level PCR & Bottle Variation - Bray Curtis"
author: "Helen Casendino"
date: "9/10/2021"
output: html_document
---
  
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
```{r Dependencies, include=FALSE}
library(tidyverse)
library(vegan)
```

This code functions similarly to centroid.comm.var.Rmd, in that it creates distributions of variability among technical (PCR) and biological (bottle) replicates at the community level, using the OA data with triplicate PCRs. It functions differently in a few ways: 
     
      1) instead of caculating the distance to the centroid for each bottle or sampling event, it harvests all bray-curtis pairwise distances from the vegdist() output
      2) For the biological replicate level (distance b/w bottles within sampling event), there is no averaging across PCRs...ie, we are collecting pairwise BC distances among A.1,A.2,A.3,B.1,B.2, etc.
      3) To avoid tabulating intra-bottle PCR variation when looking at the bio replicate level, we will only harvest pairwise distances between communities in *different* bottles...ie, take the pairwise distance between A.1 and B.1,B.2,B.3, but not between A.1 and A.2,A.3
      
## Step 1: Read in the data. 

```{r load in data}
trip.proportion.reads <- read.csv('../../data/PCR.proportions.clean.csv')
```
      
## Step 2: PCR Variation
Create and run function to 3 pairwise Bray-Curtis distances for 3 different PCR pairwise comparisons, by biological replicate

```{r create & run function to calculate BCDs by bottle; Plot}
# Function calls: 
# a) df is a data frame with columns for each PCR run and a column for bottle ID
# b) bottles is a vector of all biological sample IDs in your dataset.
# c) PCR.cols is vector of column indices for each PCR rxn 
PCR.bcd <- function(df, bottles, PCR.cols){
  bcds <-  c("start") # will hold all bray curt distances
  
  for(j in 1:length(bottles)){
    bottle.hashes <- t(df[df$bio == bottles[j],PCR.cols]) # to get all PCR props from that one sample
    dis <- vegdist(bottle.hashes)
    bcds[(length(bcds) + 1):(3 + length(bcds))] <- as.vector(dis) # takes all values of the vegdist output
    print(j)
  }
  # plot
   his <- hist((as.numeric(bcds[-1])), col = viridis::plasma(3,0.4,0.7), main = "PCR Variation", xlab = "Bray-Curtis Pairwise Distances")
  
    return(as.numeric(bcds[-1])) 
    return(his)
}

PCR.output <- PCR.bcd(trip.proportion.reads,  unique(trip.proportion.reads$bio), 3:5)
# text(0.75, 100,"mean = 0.334")
```

## Step 3: Bottle Variation
As a reminder, we are *not* averaging across PCRs.

```{r data wrangling, not taking PCR mean}
long.props <- trip.proportion.reads %>% 
  mutate(sample = gsub('.{1}$', '', bio)) %>% 
  mutate(bottle = stri_sub(bio,-1)) %>% 
  pivot_longer(cols = c(PCR1_prop,PCR2_prop,PCR3_prop), names_to = "PCR", values_to = "Proportion")

get.PCRn <- long.props %>% 
  mutate("PCRn" = stri_sub(PCR,4,-6)) %>% 
  select(-c(bio,PCR))

nested.props <- get.PCRn %>% 
  unite(bottle, PCRn, col = "bio.PCR", sep = ".") %>% 
  nest(data = c(bio.PCR,Hash,Proportion))

for(i in 1:length(nested.props$sample)) {
  
  nested.props$data[[i]] <- nested.props$data[[i]] %>% 
    group_by(bio.PCR,Hash) %>% 
    summarise(Proportion = mean(Proportion)) %>%  
    pivot_wider(names_from = bio.PCR, values_from= Proportion, values_fill = 0) 
  
  print(i)
}
```

```{r create & run function to calculate BCDs by sampling event; Plot}
# list = list of data frames corresponding to each sampling event. Within each df, columns correspond to bioPCR combos (A1, B3, C2 etc) and rows correspond to each Hashes
# SampleVector is vector of sampling events (PO20170311, etc)
BOTTLE.bcd <- function(list, SampleVector){
  bcds <- "start"
 
  # Getting rid of samples with only one bottle
   for(i in 1:length(SampleVector)){
  a <- list[[i]]
  if(((ncol(a) -1)/3) == 1){
   SampleVector <- SampleVector[-i]
  }
}
  
  for(j in 1:length(SampleVector)){
    df <- list[[j]]
    sub.tib <- df %>% select(!c(Hash))
    flip.tib <- t(sub.tib)
    dis <- vegdist(flip.tib) 
  
     # getting rid of intra-bottle pairwise comparisons
    dis.mat <- as.matrix(dis) 
  
    while(hmmm){ # can i make this while loop stop when it gets an error? I just need it to run thru all lines of code that fit into the matrix dimensions...the errors themselves are not problematic, just that it stops the whole loop...i want the function to run through each line of code until an error is thrown and then move on
      dis.mat[1:3,1:3] <- NA
    dis.mat[4:6,4:6]  <- NA
    dis.mat[7:9,7:9] <- NA
    dis.mat[10:12,10:12] <- NA
    dis.mat[13:15,13:15] <- NA
    dis.mat[16:18,16:18] <- NA
    }
    
    bcd.vector <- unique(as.numeric(na.omit(as.vector(dis.mat)))) 
     bcds[(length(bcds) + 1):(length(bcd.vector) + length(bcds))] <- bcd.vector # all unique bray curtis dists for that sample
      print(j)
  }
       his <- hist((as.numeric(bcds[-1])), col = viridis::plasma(3,0.4,0.7), main = "Bottle Variation", xlab = "Bray-Curtis Pairwise Distances")
  
 return(as.numeric(bcds[-1])) 
 return(his)
}

bottle.output <- BOTTLE.bcd(nested.props$data, nested.props$sample)
```

Think about how to run while loop..  get around the error issues, as mentioned...I can't think of how to loop through these subsets based on bottle n (2 bottles needs 1st two subsets, 3 bottles needs 1st three, etc) so that I wouldn't need each to take up one line of code
      
      