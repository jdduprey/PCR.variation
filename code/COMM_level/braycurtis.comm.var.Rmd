---
title: "Community Level PCR & Bottle Variation - Bray Curtis"
author: "Helen Casendino, Joe Duprey"
date: "9/28/2021"
output: html_document
---
  
```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r dependencies, include = FALSE}
library(tidyverse)
library(vegan)
library(stringi)
```

This code functions similarly to centroid.comm.var.Rmd, in that it creates distributions of variability among technical (PCR) and biological (bottle) replicates at the community level, using the OA data with triplicate PCRs. It functions differently in a few ways: 
     
      1) instead of calculating the distance to the centroid for each bottle or sampling event, it harvests all bray-curtis pairwise distances from the vegdist() output
      2) For the biological replicate level (distance b/w bottles within sampling event), there is NO AVERAGING ACROSS PCRs...ie, we are collecting pairwise BC distances among A.1,A.2,A.3,B.1,B.2, etc.
      3) To avoid tabulating intra-bottle PCR variation when looking at the bio replicate level, we will only harvest pairwise distances between communities in *different* bottles...ie, take the pairwise distance between A.1 and B.1,B.2,B.3, but not between A.1 and A.2,A.3
      
## Step 1: Read in the data

```{r load in data}
kai_PCR_props <- read.csv("../../data/kai_PCR_props.csv")
```
      
## Step 2: PCR Variation

We create a function that computes the pairwise Bray-Curtis dissimilarities among technical replicates within each biological sample, stores all obtained values in a numeric vector, and plots those values in histogram. Our function allows the user to specify which sequence runs should be analyzed (by default, all will be used), hence the seq_runs vector parameter. Below we also test our function on our OA data.

```{r create and run find_PCR_BCDs function}
# Computes pairwise Bray-Curtis dissimilarities among technical replicates from 
# each biological sample. Returns a vector of those values and a histogram.
# Args:
#   df: A data frame with columns for bio, tech, hash, prop, and seq_run.
#   seq_runs: A vector containing the numbers of the seq runs to be analyzed.
find_PCR_BCDs <- function(df, seq_runs = unique(df$seq_run)) {  # Includes all seq runs by default
  
  # Note: When we generalize this function to not require triplicates, we will
  # initiate a list (bcds) full of NA values with length of max(df$tech) times
  # length(bottles). Afterwards, we'll remove all NA values to get our desired
  # vector.
  
  # Data wrangling in preparation for the vegdist function
  df <- df %>% 
    filter(seq_run %in% seq_runs) %>% 
    select(bio, tech, hash, prop) %>%
    pivot_wider(names_from = tech, values_from = prop, values_fill = 0)
  
  bottles <- unique(df$bio)
  bcds <- vector(mode = "numeric", length = 3 * length(bottles))  # TODO (KAI): GENERALIZE
  PCR_cols <- 3:5  # WILL BE GENERALIZED
  i <- 1
  
  # Iterate over each bottle and calculate BCDs among PCRs
  for (b in bottles) {
    hashes <- t(df[df$bio == b, PCR_cols])  # To get all props from that one bottle
    dis <- vegdist(hashes)  # Calculate BCDs
    bcds[i : (i + 2)] <- as.vector(dis)
    i <- i + 3  # GENERALIZE
  }
  
  # Sanity check
  print("Bray-Curtis Dissimilarities:")
  print(bcds)
  print(paste("Mean BCD value:", mean(bcds), sep = " "))
  
  # Plot
  his <- hist(bcds,
              col = viridis::plasma(3, 0.4, 0.7),
              main = "PCR Variation",
              xlab = "Pairwise Bray-Curtis Dissimilarities")

  return(bcds)
  return(his)
}

# Run the function with our data
# TODO : FIGURE OUT WHAT'S UP WITH 5 AND 6 AND ALSO DIFFERNECES BETWEEN SEQ RUNS
PCR_output <- find_PCR_BCDs(kai_PCR_props, 1)
```

## Step 3: Bottle Variation

As a reminder, we are *not* averaging across PCRs.

```{r helper function for data wrangling}
# A helper function for data wrangling. Prepares a data frame for the
# find_bottle_BCDs function by nesting the data by site.
# Args:
#   df: A data frame with columns for bio, tech, hash, prop
nest_data <- function(df) {
  nested_data_by_site <- df %>% 
    ungroup() %>%  # TODO : DELETE LINE ONCE I'M DONE TESTING
    mutate(site = gsub(".{1}$", "", bio)) %>%  # Separate site and bottle info from each other
    mutate(bottle = stri_sub(bio, -1)) %>% 
    select(site, bottle, tech, hash, prop) %>% 
    unite(bottle, tech, col = "bio.PCR", sep = ".") %>%  # Combine to get A.1, A.2, etc.
    arrange(site, bio.PCR, hash) %>% 
    nest(data = c(bio.PCR, hash, prop))
  
  # At this point, nested_data_by_site has the following structure:
  #   site       data           
  #   <chr>      <list>              
  # 1 PO20170311 <tibble [1,824 × 3]>
  # 2 LL20170311 <tibble [1,670 × 3]>  
  
  # Each element of site_data looks like this:
  #   bio.PCR hash                                      prop
  #   <chr>   <chr>                                    <dbl>
  # 1 F.1     11a112ced1c85e620f6d97d82281a1bb58614e67 0.262
  # 2 A.3     11a112ced1c85e620f6d97d82281a1bb58614e67 0.363
  
  # Change columns to: hash, A.1, A.2, A.3, B.1, B.2, etc.
  for (i in 1:length(nested_data_by_site$data)) {
    nested_data_by_site$data[[i]] <- nested_data_by_site$data[[i]] %>%
      pivot_wider(names_from = bio.PCR, values_from = prop, values_fill = 0)
  }
  
  return(nested_data_by_site)
}
```


```{r create & run function to calculate BCDs by sampling event; Plot}
# Computes pairwise Bray-Curtis dissimilarities across different biological
# replicates (but not among PCRs from the same bottle). Returns a vector of
# those values and a histogram.
# Args:
#   df: A data frame with columns for bio, tech, hash, prop, and seq_run.
find_bottle_BCDs <- function(df) {
  df <- nest_data(df)  # Data wrangling using helper function from above
  list <- df$data  # A list of data frames corresponding to each sampling event
  # Note: Within each df, columns correspond to bio.PCR combos (in order!) and
  # rows correspond to individual hashes
  
  SampleVector <- df$site  # A vector of sampling events (PO20170311, etc)
  
  bcds <- "start"

  # Getting rid of samples with only one bottle
  onebottle <- rep(NA, length = 100) # we will put the "list" indices of replicates with only one bottle here

  for (i in 1:length(SampleVector)) {
    a <- list[[i]]
    if (((ncol(a) - 1) / 3) == 1) { # replicates with only 1 bottle
      onebottle[i] <- i # save index
      SampleVector <- SampleVector[-i] # remove index from sample vector
    }
  }
  onebottle <- onebottle[!is.na(onebottle)] # remove NAs
  list <- list[-onebottle] # remove the one bottle elements from list

  for (j in 1:length(SampleVector)) {
    print(j)

    df <- list[[j]]
    sub.tib <- df %>% select(!c(hash))
    flip.tib <- t(sub.tib)
    dis <- vegdist(flip.tib)
    dis.mat <- as.matrix(dis)

    # PRINT DISTANCE MATRICES BEFORE REMOVAL <- can remove later // joe getting up to speed
    print(SampleVector[j])
    print(dis.mat)

    # getting rid of intra-bottle pairwise comparisons...
    # remove all cells corresponding to distances within the same bottle
    tryCatch(
      {
        dis.mat[1:ncol(dis.mat), 1:3] <- NA
        dis.mat[4:ncol(dis.mat), 4:6] <- NA
        dis.mat[7:ncol(dis.mat), 7:9] <- NA
        dis.mat[10:ncol(dis.mat), 10:12] <- NA
        dis.mat[13:ncol(dis.mat), 13:15] <- NA
        dis.mat[16:ncol(dis.mat), 16:18] <- NA
        if (j == j) stop("subscript out of bounds")
      },
      error = function(e) {}
    )

    # PRINT DISTANCE MATRICES AFTER REMOVAL <- can remove later // joe getting up to speed
    print(dis.mat)

    bcd.vector <- as.numeric(na.omit(as.vector(dis.mat))) # remove intra-bottle comparisons
    bcds <- c(bcds, bcd.vector) # all bray curtis dists for that sample
  }

  # plot
  his <- hist((as.numeric(bcds[-1])), col = viridis::viridis(3, 0.4, 0.7), main = "Bottle Variation", xlab = "Bray-Curtis Pairwise Distances")

  return(as.numeric(bcds[-1]))
  return(his)
}

bottle.output <- find_bottle_BCDs(data)
# mean = 0.431
```

      
