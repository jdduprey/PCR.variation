---
title: "rareSp.dissimilarity"
author: "Helen Casendino"
date: "7/26/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
```{r Dependencies, include=FALSE}
library(tidyverse)
library(vegan)
```

This code will look at the impact of rare species on dissimilarity between PCR replicates. We'll start with PCR.proportions.clean.csv, which has the proportions of each hash by PCR replicate (ONLY triplicate PCR samples) and really low read PCR replicates are removed. 

```{r load in data}
full.proportion.reads <- read.csv('../data/PCR.proportions.clean.csv')
```

Below is my start to making the subsetting loop with BCD centroids for each sample. So, for each sample, we'll have a rank of most common hashes to least common. We will subset this with varying exclusion proportions (ie, removing bottom 1% of hashes, bottom 5%). For each subset, calculate the centroid of 3 pairwise bray curtis dissimilarities: PCRs 1&2, 2%3 and 1&3.   

```{r Function that calculates centroids by sample across rare sp subsets}

# df is a data frame with 6 columns: Miseq_run, bio, Hash, PCR1_prop, PCR2_prop, PCR3_prop
# exclusionProp is a vector of all the subsetting proportions you want. A vector of (0.01, 0.05) means you'll get the PCR centroid for when 1% of the lowest proportion samples are excluded, and when 5% of lowest prop samples are excluded.
# bioVector is a vector of all biological sample IDs in your dataset.

PCRcentroid_bySample <- function(df, exclusionProp, bioVector){
   
  mat <- matrix(NA, nrow = length(exclusionProp), ncol = length(bioVector))
  
  for(j in 1:length(bioVector)){
    
      bioSample <- bioVector[j]
      bioProps_Hashes <- df[df$bio == bioSample,] # to get all PCR props from that one sample
      
      meanProp.acrossPCR <- bioProps %>% group_by(Hash) %>% summarise(meanProp.PCR = mean(c(PCR1_prop, PCR2_prop,PCR3_prop))) %>% arrange(desc(meanProp.PCR)) # to get rarity order
      
      for(i in 1:length(exclusionProp)){
       cutoff <- round(length(meanProp.acrossPCR$Hash) - length(meanProp.acrossPCR$Hash)*exclusionProp[i])
        sub.tib <- meanProp.acrossPCR[1:cutoff,]
        sub.tib <- bioProps_Hashes %>% filter(Hash %in% sub.tib$Hash) %>% select(!c(Hash, bio,Miseq_run))
        
        #### GET CENTROID HERE SOMEHOW
        mat[i,j] <- centroid
      }
    
    print(j)  # progress bar
  }
  return(mat)
}

# returns a matrix with biological replicate as columns and exclusion proportion as rows. 

```

One thing that's missing from the above function- I still need to figure out how to calculate the centroid for our PCR pairwise comparisons using Ramon's function...do we need to calculate BCD between the PCRs in a separate function and then get centroid, or does betadisper do that for us..

```{r figuring out centroid}
# does betadisper just need a vector of BCDs...? 

# this is the function Moncho provided
distn.to.centroid <- function(dist){
    grouping <- rep(attr(dist, "size"), "biol")
   centroid<- betadisper(dist, group = grouping)
  return(centroid$distances)
}

# practice

bioProps_Hashes <- full.proportion.reads[full.proportion.reads$bio == "PO20170311F",]
sub.tib <- bioProps_Hashes %>%select(!c(Hash, bio,Miseq_run))
flip.tib <- t(sub.tib)
dis <- vegdist(flip.tib)
grouping <- factor(c(1, 2, 3), labels = c("PCR1_prop","PCR2_prop", "PCR3_prop"))
centroid<- betadisper(dis, group = grouping)
centroid$distances # I definitely did this wrong, all 0s... but at least the grouping variables are correct, maybe just not the data they're attaching to...everything looks good up until centroid$distances is called
```






