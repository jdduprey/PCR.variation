---
title: "bio.comm.level.var"
author: "Helen Casendino, Joe Duprey"
date: "8/23/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
```{r Dependencies, include=FALSE}
library(tidyverse)
library(vegan)
library(gridExtra)
```

This script replicates Helen's code for measuring community level variance, but at the level of biologial replicates
- bottle samples within a site-date. 

## Step 1: Read in the data. 

need to read in data from ASV level script that has bottle replicates arranged by row. 

 - trip.proportion.reads = the proportions of each hash by PCR replicate (ONLY triplicate PCR samples) and biological samples with really 1 low read PCR replicate are removed

```{r}
# trip.proportion.reads <- read.csv('../data/PCR.proportions.clean.csv')
PCR.props <- read.csv('../data/PCR.proportions.clean.csv')
```

## Step 2: 

Define function that gets mean distance to centroid for all pairwise comparisons within a site-date. In the OA data set this varies from ~ 9 - 15. 

```{r}
site.date.nest <- nest(site.date.prop, data=!sample)

```

```{r}
# define function to use with each nested data? 

bray_by_sample <- function(df, bioVector, indexCols){  
  
    centroid.mat <- matrix(NA, nrow = length(bioVector), ncol = 3, dimnames = list(bioVector, c('rep1','rep2','rep3')))
    # different PCR rep combinations
  
  for(i in 1:length(bioVector)){
    sample.tib <- df[df$bio == bioVector[i],indexCols]
    bray.tib <- t(sample.tib)
    bray.results <- as.matrix(vegdist(bray.tib, method="bray", na.rm = T))
    
    ### MODIFIED CODE TO GET DISTANCE OF EACH TECH REPLICATE TO CENTROID **needs review**
    dis <- vegdist(bray.tib, method="bray", na.rm=T) # bray distance object
    groups <- factor(rep(1,3), labels=bioVector[i]) # groups, this is just vector of 3 with the bio replicate 
    mod <- betadisper(dis, groups) # calculate the distance 
    #print(mod)
    #print('-------------------------------------------------------')
    #print((mod$distances[1] + mod$distances[2] + mod$distances[3])/3)
    #print(mod$distances) 
    
    centroid.mat[i,] <- mod$distances
  }
    return(centroid.mat)
}

```



