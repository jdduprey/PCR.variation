---
title: "Dividing OA PCR replicates and calculating eDNA index by replicate"
author: "Joe Duprey, Helen Casendino"
date: "7/20/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
```{r Dependencies, include=FALSE}
library(tidyverse)
source('./eDNA_index.r') # Moncho's script

```

First import raw ASV's from OA project. This data is the input data to Moncho's original workflow. None of his QA steps have been applied to the raw.ASVs data table. 

```{r load data, create technical and bio replicate columns }
raw.ASVs <- read.csv('../input/raw_ASVs.csv')

by.tech.table <- raw.ASVs %>%
  filter(str_detect(sample, "Ostrich", TRUE)) %>% # remove ostrich samples
  filter(str_detect(sample, "Kangaroo", TRUE)) %>% # remove kangaroo samples
  separate(col=sample, into=c('bio','tech'), sep='[.]', remove=FALSE) # divide sample into technical and bio reps

# check for repeats 
by.tech.table %>%
  group_by(sample, bio, tech, Hash, nReads) %>%
  filter(n()>1)
```

The following code uses Moncho's handy eDNA index function, but we're not sure how to use it to calculate
index for replicates separately which is our goal here. 

```{r calculate eDNA index}
# this won't work? need to calculate eDNA index after splitting into 
# technical replicates, because read depth will vary! 
# by.tech.table <- eDNAindex(by.tech.table, sample, Hash, nReads, bio)

```

Useful code from Ryan to check min and max of each Hash to see if the calculated index makes sense 

```{r Ryan's eDNA index check}
# index.check <- by.tech.table %>% 
#   group_by(Hash) %>% 
#   summarize(max(Normalized.reads),
#             min(Normalized.reads))
# 
# unique(index.check$'max(Normalized.reads)')
```

Now we format our table so technical replicates are separate columns. First we need to get rid of sets of PCR replicates with only 2, might add these back in later? 

```{r filter to 3 replicates, shape PCR replicates into columns }
# find the replicates with 3 
three_reps <- by.tech.table %>%
  group_by(bio) %>%
  summarise(nrep = n_distinct(bio, tech)) %>%
  filter(nrep == 3)

# only keep the biological replicates with 3 PCR reps 
clean.tech.table <- by.tech.table %>%
  filter(bio %in% three_reps$bio)

# widen the table, PCR replicates are now columns 
clean.tech.table <- clean.tech.table %>%  
   select(bio, tech, Hash, nReads) %>%
   pivot_wider(names_from=tech, values_from=nReads, values_fill=0)

```

Now we need to calculate eDNA index for each column, and rename the columns to something more clear

```{r}
#rename PCR replicate columns to avoid confusion 
clean.tech.table <- clean.tech.table %>%
  rename('PCR1_reads'='1', 'PCR2_reads'='2', 'PCR3_reads'='3')

# make a function to use on each PCR replicate column 
# ===================================================
# df: DATAFRAME
# nReads: STRING column with the raw read counts to use function on STRING 
# new_name: STRING new name for new column containing eDNA index 
# ===================================================
calc_eDNA_index <- function(df, nReads, new_name) { 
  df <- df %>%
    group_by(bio) %>% # read depth
    mutate(totalReads = sum(.data[[nReads]]),
          propReads = .data[[nReads]]/totalReads) %>% 
    group_by(Hash) %>% 
    mutate(eDNA_index = propReads/(max(propReads))) %>%
    rename(!!new_name := eDNA_index) %>% 
    select(-c(propReads, totalReads))
    
  
  return(df)
} 

clean.tech.table <- calc_eDNA_index(df=clean.tech.table,
                                    nReads='PCR1_reads', new_name='PCR1_index')
clean.tech.table <- calc_eDNA_index(df=clean.tech.table,
                                    nReads='PCR2_reads', new_name='PCR2_index')
clean.tech.table <- calc_eDNA_index(df=clean.tech.table,
                                    nReads='PCR3_reads', new_name='PCR3_index')

# is it okay to change these to zeros!? 
#clean.tech.table <- clean.tech.table %>% 
#  replace(is.na(.), 0)

write_csv(clean.tech.table, '../data/clean.tech.table.csv')
```

Use Ryan's check for correct eDNA index 

```{r}
index.check <- clean.tech.table %>% 
  group_by(Hash) %>% 
  summarize(max(PCR1_index),
            min(PCR1_index))

unique(index.check$'max(PCR1_index)')
```
```{r}
# nest.table <- nest(clean.tech.table, data=c(Hash, PCR1_reads, PCR2_reads, PCR3_reads, PCR1_index, PCR2_index, PCR3_index))
```

