---
title: "Calculate hash proportions within samples (& triplicate eDNA index)"
author: "Joe Duprey, Helen Casendino, Ramon Gallego"
date: "8/25/2021"
output: html_document
---

# Overview
This code creates the following four csv files: 
  1) PCR_props.csv. This code calculates the proportions for each hash within a PCR triplicate without removing PCR replicates with low reads.
  2) PCR_props.clean.csv. This code calculates the proportions for each hash within a PCR triplicate AFTER removing PCR replicates with low reads.
  3) PCR.duplic.proportions.csv. This code calculates the proportions for each hash within a PCR duplicate. These duplicate include true duplicates AND samples that had one PCR replicate removed in the earlier low read quality control step. 
  4) PCR.index.clean.csv. This code calculates the eDNA index for each hash within a PCR triplicate.
  
  **NOTE: For PCR_props.clean.csv and PCR.duplic.proportions.csv, hash proportions are averaged across duplicate MiSeq runs, where the same bottles and corresponding hashes were run through two Miseq runs (I believe Miseq runs 5 & 6 have duplicates)**
  
```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r Dependencies}
library(tidyverse)
```

First get raw ASV data. 

```{r Load data and create technical and biological replicate columns}
raw_ASVs <- read.csv("../input/raw_ASVs.csv") # ADD NOTES ABOUT REQUIRED FORMAT FOR INPUT

by_tech <- raw_ASVs %>%
  rename(seq_run = Miseq_run, hash = Hash, reads = nReads) %>%  # for consistent lowercase names
  filter(str_detect(sample, "Ostrich", TRUE)) %>% # remove ostrich samples
  filter(str_detect(sample, "Kangaroo", TRUE)) %>% # remove kangaroo samples
  filter(str_detect(sample, "K+", TRUE)) %>% # remove negative control (??) samples
  filter(str_detect(sample, "k+", TRUE)) %>%
  mutate(sample = gsub("_", "", sample)) %>% # for consistency across sample names
  separate(col = sample, into = c("bio", "tech"), sep = "[.]", remove = FALSE) %>% # WHY DON'T WE REMOVE?
  group_by(sample, bio, tech, hash, reads) %>% # eliminate duplicates
  filter(n() == 1) # THIS SHOULD BE EQUALS, RIGHT?
```

## Triplicate proportions with low reads included

For now, only use samples with 3 PCR replicates. 

```{r Filter in triplicates}
triplicates <- by_tech %>%
  group_by(bio) %>%
  summarise(nrep = n_distinct(bio, tech)) %>%
  filter(nrep == 3)
```

Now, we want to get the proportion of reads for each hash (reads of hash/total reads in the bio sample for each tech rep). 

```{r Getting hash proportions}
PCR_props <- by_tech %>% 
  filter(bio %in% triplicates$bio) %>% # only take bio reps with three PCR reps
  group_by(bio, tech) %>% 
  mutate(prop = reads / sum(reads)) %>% 
  select(bio, tech, hash, prop) %>%
  pivot_wider(names_from = tech, values_from = prop, values_fill = 0) %>%
  rename(c("PCR1_prop" = "1", "PCR2_prop" = "2", "PCR3_prop" = "3"))
```

Save the new data frame. 

```{r Include df in data}
write_csv(PCR_props, "../data/PCR_props.csv")
```



## Triplicate proportions with low reads removed

Data frame that excludes very low reads within PCR triplicates. We'll adapt our code from Step 2 of Moncho's (Denoising.all.runs.Rmd) in the OA paper, where reads are fit to a normal distribution and those with low reads outside of the 95% CI are removed. 

```{r Fit reads to normal dist}

triplicate.data.allreads <- by_tech %>%
  filter(bio %in% triplicates$bio)

all.reads.sums <- triplicate.data.allreads %>%
  group_by(sample) %>%
  summarise(tot = sum(reads)) # getting sum of reads for each PCR replicate

# visualize total read distribution
hist(all.reads.sums$tot, breaks = 80)

reads.per.sample <- all.reads.sums %>%
  pull(tot)

names(reads.per.sample) <- all.reads.sums %>% pull(sample)

normparams.reads <- MASS::fitdistr(reads.per.sample, "normal")$estimate
```

Now we'll get the PCR replicates with reads below the 95% interval and remove those from the data set. We'll create a revise proportions csv. 

```{r Removing reads outside of 95% interval}
all.reads.sums <- all.reads.sums %>%
  mutate(prob = pnorm(tot, normparams.reads[1], normparams.reads[2]))

outliers <-
  all.reads.sums %>%
  filter(prob < 0.075 & tot < normparams.reads[1])
```

So taking a break here - we now have biological replicates that need one PCR replicate removed because it's read was too low. So in essence, these samples are now duplicates. We can combine these samples with our true duplicates to make a triplicate and a duplicate table. 

```{r Isolate duplicates}
# Getting true duplicates
two_reps <- by_tech %>%
  group_by(bio) %>%
  summarise(nrep = n_distinct(bio, tech)) %>%
  filter(nrep == 2)

# biological sample identifiers of outliers from triplicate (low reads, now duplicates). Add these two two_reps
outliers$bio <- gsub("..$", "", outliers$sample)
two_reps_full <- two_reps %>% rows_insert(tibble(bio = outliers$bio, nrep = 2))
```

Now remove the new duplicate samples from the triplicate set.
We'll make the triplicate proportion table here. We also don't want duplicates across Miseq runs (the same bio.hash row for Miseq runs 5 & 6), so we will average proportion across Miseq runs. 

```{r removing duplicates from triplicate & making triplicate prop table}

true.triplicate.data <- by_tech %>%
  filter(!bio %in% two_reps_full$bio)

PCR_props.clean <- true.triplicate.data %>%
  group_by(bio, tech) %>% # removed seq_run 8/27 see above - joe
  mutate(prop = reads / sum(reads)) %>%
  select(bio, tech, hash, prop) %>%
  pivot_wider(names_from = tech, values_from = prop, values_fill = 0) %>%
  dplyr::rename(c("PCR1_prop" = "1", "PCR2_prop" = "2", "PCR3_prop" = "3")) %>%
  group_by(bio, hash) %>%
  summarise_at(c("PCR1_prop", "PCR2_prop", "PCR3_prop"), mean)

write_csv(PCR_props.clean, "../data/PCR_props.clean.csv")
# something like this to get hash proportions between bio replicates
# PCR.by.bio.clean <- triplicate.data.clean %>%
#   group_by(seq_run, bio, tech) %>%
#   mutate(prop = reads/sum(reads)) %>%
#   select(seq_run, bio, tech, hash, prop) %>%
#   pivot_wider(names_from=bio, values_from=prop, values_fill=0) #%>%
# rename(c("PCR1_prop" = "1", "PCR2_prop" = "2", "PCR3_prop" = "3"))

# write_csv(PCR.by.bio.clean, '../data/PCR_props.clean.csv')
```



## Duplicate proportions 

Now, we also need to repeat with our duplicates! As a reminder, we also need to check for low reads from these. 

```{r creating full duplicate df}

duplicate.data <- by_tech %>%
  filter(bio %in% two_reps_full$bio) # both low read and true duplicates

# remove PCR *replicates* that had low reads (so leave the remaining two for that bio sample)
duplicate.data.clean <- duplicate.data %>% filter(!sample %in% outliers$sample)
```

Now we're gonna check, just to make sure, that no reads from the true duplicates are really low. 

```{r checking to make sure no dups have really low reads}
# all.reads.sums <- duplicate.data.clean %>%  group_by(sample) %>%
#  summarise(tot = sum(reads))

# reads.per.sample <- all.reads.sums %>%
#  pull(tot)

# names(reads.per.sample) <- all.reads.sums %>% pull(sample)

# normparams.reads <- MASS::fitdistr(reads.per.sample, "normal")$estimate

# all.reads.sums <- all.reads.sums %>%
#  mutate(prob = pnorm(tot, normparams.reads[1], normparams.reads[2]))

# all.reads.sums %>%
#  filter(prob < 0.075 & tot < normparams.reads[1])
```

Nothing too low! So, let's make a csv with duplicate proportions. But ew, some samples have PCR 1&2, others have PCR 2&3, etc. So let's change all to PCR 1&2. 

```{r duplicate data table clean up}
# bioVector is list of unique bio sample IDs, tech.col is the column of the df that lists tech rep
standard_PCRnums <- function(dup.df, bioVector, tech.col) {
  for (i in 1:length(bioVector)) {
    allPCR.nums <- dup.df[dup.df$bio == bioVector[i], tech.col] # part of dup.df for 1 bio sample that lists all tech rep numbers
    uniquePCR.nums <- unique(dup.df[dup.df$bio == bioVector[i], tech.col]) # what are the 2 numbers of the PCR reactions done? ie, 1 & 2, 2 & 3, etc.

    rows1 <- which(allPCR.nums == uniquePCR.nums[1]) # which rows equal the 1st PCR rep
    rows2 <- which(allPCR.nums == uniquePCR.nums[2])

    allPCR.nums[rows1] <- "1" # convert the first PCR number to 1 within the tech column of the loop's dataframe
    allPCR.nums[rows2] <- "2"
    dup.df[dup.df$bio == bioVector[i], tech.col] <- allPCR.nums # put this new number string into dup.df
  }
  return(dup.df)
}

standard.props <- standard_PCRnums(duplicate.data.clean, unique(duplicate.data.clean$bio), 4)
```


```{r duplicate proportions}

# calculate duplicate proportions
PCR.duplic.proportions <- standard.props %>%
  group_by(bio, tech) %>% # removed seq_run 8/27, see above
  mutate(prop = reads / sum(reads)) %>%
  select(bio, tech, hash, prop) %>%
  pivot_wider(names_from = tech, values_from = prop, values_fill = 0) %>%
  dplyr::rename(c("PCR1_prop" = "1", "PCR2_prop" = "2")) %>%
  group_by(bio, hash) %>%
  summarise_at(c("PCR1_prop", "PCR2_prop"), mean)

write_csv(PCR.duplic.proportions, "../data/PCR.duplic.proportions.csv")
```

## Triplicate eDNA INDICES with low reads removed

I also want to create a csv with eDNA index values instead of proportions. 

```{r Sourcing eDNA index func}
# source("/Users/helencasendino/Desktop/PCR.variation/code/eDNA indexing/helen.eDNA_index.R") # modified index function (need to fix source path)
calc_eDNA_index <- function(df, PCRcols) {
  for (i in 1:length(PCRcols)) {
    nRead.col <- colnames(df)[PCRcols[i]] # col name of PCR column

    df[, nRead.col] <- df %>%
      group_by(bio) %>% # "convert read counts to proportion with biological sample"
      mutate(
        totalReads = sum(.data[[nRead.col]]),
        props = .data[[nRead.col]] / totalReads
      ) %>%
      group_by(hash) %>% # "scale the resulting proportion to the largest observed proportion across samples"
      mutate(index = props / (max(props)), .keep = "none") %>%
      ungroup() %>%
      select(-hash)

    NArows <- which(is.na(df[, nRead.col]) == T)
    df[NArows, nRead.col] <- 0
  }
  colnames(df)[PCRcols] <- c("PCR1_index", "PCR2_index", "PCR3_index") # rename columns to "index"
  return(df)
}
```

```{r run function on trip data}
# Make trip data wide (1 column per PCR)
wide <- true.triplicate.data %>%
  select(bio, tech, hash, reads) %>%
  pivot_wider(names_from = tech, values_from = reads, values_fill = 0)

wide.named <- wide %>%
  rename("PCR1_reads" = "1", "PCR2_reads" = "2", "PCR3_reads" = "3")

PCR.index.clean <- calc_eDNA_index(wide.named, c(3:5))
write_csv(PCR.index.clean, "../data/PCR.index.clean.csv")
```

#####################################################################################
