---
title: "joe.rareSp"
author: "Helen Casendino, Joe Duprey"
date: "7/22/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
library(vegan)
library(reshape)
# source("dissimilarity.exploration.Rmd")
```


```{r load data}
full.proportion.reads <- read.csv('../data/PCR.proportions.clean.csv')
```

```{r}
full.proportion.long <- full.proportion.reads %>%
  pivot_longer(cols=c('PCR1_prop','PCR2_prop','PCR3_prop'), names_to='tech',values_to='PropRead')
```


```{r}
# don't know how to import function from Rmd
#bioVector = list of unique biological replicate IDs, indexCols = col numbers of eDNA proportion values (by PCR #). df needs to have 3 columns corresponding to eDNA proportions of different PCR runs

bray_by_sample <- function(df, bioVector, indexCols){  
  
    #bray.mat <- matrix(NA, nrow = length(bioVector), ncol = 3, dimnames = list(bioVector, c(1.2,2.3,1.3)))
    centroid.mat <- matrix(NA, nrow = length(bioVector), ncol = 3, dimnames = list(bioVector, c('rep1','rep2','rep3')))
    # different PCR rep combinations
  
  for(i in 1:length(bioVector)){
    sample.tib <- df[df$bio == bioVector[i],indexCols]
    bray.tib <- t(sample.tib)
    bray.results <- as.matrix(vegdist(bray.tib, method="bray", na.rm = T))
    
    ### MODIFIED CODE TO GET DISTANCE OF EACH TECH REPLICATE TO CENTROID **needs review**
    dis <- vegdist(bray.tib, method="bray", na.rm=T) # bray distance object
    groups <- factor(rep(1,3), labels=bioVector[i]) # groups, this is just vector of 3 with the bio's name?
    mod <- betadisper(dis, groups) # calculate the distance 
    
    #print(mod$distances[1:3])
    centroid.mat[i,] <- mod$distances[1:3]
  }
    return(centroid.mat)
}

```

```{r}

filter_proprank <- function(df, proportion, use_rank=TRUE) {
   
  if (use_rank==FALSE) {
    
    # original rows
    original.rows <- nrow(df)
    print(original.rows)
    
    result.long <- df %>%
    filter(df$PropRead >= proportion) 
    
    # kept rows 
    kept.rows <-nrow(result.long)
    print('------------------')
    print(kept.rows)
    
    # rows eliminates
    rows.eliminated <- (original.rows - kept.rows)/original.rows
    print(rows.eliminated)
  } 
  
  else {
  # the original observations in long data form
  original.obs <- df
  original.obs$ID <- seq.int(nrow(original.obs))

  # arange observation by ascending ReadProp, then "skim" off rows based on given prop
  rows_to_zero <- original.obs %>%
    filter(PropRead > 0) %>%
    arrange(PropRead) %>%
    filter(row_number() <= proportion * n()) # * n()  # should this be great or less than *******

  # if observations are in the skimmed rows, set them to zero
  result.long <- original.obs %>%
    mutate(PropRead = ifelse(ID %in% rows_to_zero$ID, 0, PropRead))
  
  }
  # flatten the df to feed into bray_by_sample() function 
  result.wide <- result.long %>%
    select(Miseq_run, bio, tech, Hash, PropRead) %>%
    pivot_wider(names_from=tech, values_from=PropRead, values_fill=0) 
  
  centroid.dists <- as.data.frame(bray_by_sample(result.wide, unique(result.wide$bio), c(4:6)))
  ####
  centroid.dists$prop <- proportion # show which prop cutoff it came from on the big df 
  # get the mean distance per bio rep
  centroid.dists$mean.bio <- (centroid.dists$rep1 + centroid.dists$rep2 + centroid.dists$rep3)/3 
  # get the mean distance for all bio reps combined
  centroid.dists$mean.all <-mean(centroid.dists$mean.bio)
  centroid.dists$rows.el <- rows.eliminated 
    
  return(centroid.dists)
  
}

test <- filter_proprank(full.proportion.long, 0.2, use_rank=FALSE)
```

```{r}

x <- seq(0,0.2, by=0.01)
datalist = vector(mode = "list", length = length(x))
it <- 1 

for (i in x){
  
  
  dat <- filter_proprank(full.proportion.long, i, use_rank=FALSE) 
  hist(dat$mean.bio, breaks=30)
  print(i)
  datalist[[it]] <- dat
  
  it <- it+1
}

eily.plot.df = do.call(rbind, datalist)
```

```{r}
ggplot(eily.plot.df, aes(x=prop, y=mean.all)) + geom_point()
```

