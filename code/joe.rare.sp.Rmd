---
title: "joe.rareSp"
author: "Helen Casendino, Joe Duprey"
date: "7/22/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
library(vegan)
library(reshape)
# source("dissimilarity.exploration.Rmd")
```


```{r load data}
full.proportion.reads <- read.csv('../data/PCR.proportions.csv')
```

```{r}
full.proportion.long <- full.proportion.reads %>%
  pivot_longer(cols=c('X1','X2','X3'), names_to='tech',values_to='PropRead')
```

```{r}
# don't know how to import function from Rmd
#bioVector = list of unique biological replicate IDs, indexCols = col numbers of eDNA proportion values (by PCR #). df needs to have 3 columns corresponding to eDNA proportions of different PCR runs

bray_by_sample <- function(df, bioVector, indexCols){  
  
    #bray.mat <- matrix(NA, nrow = length(bioVector), ncol = 3, dimnames = list(bioVector, c(1.2,2.3,1.3)))
    centroid.mat <- matrix(NA, nrow = length(bioVector), ncol = 3, dimnames = list(bioVector, c('rep1','rep2','rep3')))
    # different PCR rep combinations
  
  for(i in 1:length(bioVector)){
    sample.tib <- df[df$bio == bioVector[i],indexCols]
    bray.tib <- t(sample.tib)
    bray.results <- as.matrix(vegdist(bray.tib, method="bray", na.rm = T))
    
    ### MODIFIED CODE TO GET DISTANCE OF EACH TECH REPLICATE TO CENTROID **needs review**
    dis <- vegdist(bray.tib, method="bray", na.rm=F) # bray distance object
    groups <- factor(rep(1,3), labels=bioVector[i]) # groups, this is just vector of 3 with the bio's name?
    mod <- betadisper(dis, groups) # calculate the distance 
    #print(mod$distances) 
    
    #bray.mat[i,] <- c(bray.results[1,2], bray.results[3,2], bray.results[1,3]) # PCR 1&2, 2&3, 1&3
    centroid.mat[i,] <- mod$distances
  }
    return(centroid.mat)
}

```

```{r}

filter_proprank <- function(df, proportion) {
  
  
  result.long <- df %>%
   filter(df$PropRead >= proportion) 
  
  # # the original observations in long data form 
  # original.obs <- df
  # original.obs$ID <- seq.int(nrow(original.obs))
  # 
  # # arange observation by ascending ReadProp, then "skim" off rows based on given prop
  # rows_to_zero <- original.obs %>%
  #   filter(PropRead > 0) %>% 
  #   arrange(PropRead) %>%
  #   filter(row_number() <= proportion * n())
  # 
  # # if observations are in the skimmed rows, set them to zero
  # result.long <- original.obs %>%
  #   mutate(PropRead = ifelse(ID %in% rows_to_zero$ID, 0, PropRead))
  
  # flatten the df to feed into bray_by_sample() function 
  result.wide <- result.long %>%
    select(Miseq_run, bio, tech, Hash, PropRead) %>%
    pivot_wider(names_from=tech, values_from=PropRead, values_fill=0) 
  
  centroid.dists <- as.data.frame(bray_by_sample(result.wide, unique(result.wide$bio), c(4:6)))
  ####
  centroid.dists$prop <- proportion
  centroid.dists$meandist <- (centroid.dists$rep1 + centroid.dists$rep2 + centroid.dists$rep3)/3
    
  return(centroid.dists)
  
}

test <- filter_proprank(full.proportion.long, 0.02)
```

```{r}
# filter_by_prop <- function(df, proportion) {
#   
#   filtered.df <- df %>%
#     filter(df$PropRead >= proportion) 
#     
#   filtered.df <- filtered.df %>%  
#     select(Miseq_run, bio, tech, Hash, PropRead) %>%
#     pivot_wider(names_from=tech, values_from=PropRead, values_fill=0) 
#     
#   #print(dim(filtered.df))  
#   
#   #filtered.df <- filtered.df %>%  
#   #  filter(X1 != 0 | X2 !=0 | X3 != 0)
#   
#   #print(dim(filtered.df))  
#   
#   
#   bray.output <- as.data.frame(bray_by_sample(filtered.df, unique(filtered.df$bio), c(4:6)))
#   
#   onetwo_mean <- mean(bray.output$'1.2')
#   twothree_mean <- mean(bray.output$'2.3')
#   onethree_mean <- mean(bray.output$'1.3')
#   
#   return(c(onetwo_mean, twothree_mean, onethree_mean))
# }
```

```{r}

x <- seq(0,0.08, by=0.01)
datalist = vector(mode = "list", length = length(x))
it <- 1 

for (i in x){
  
  dat <- filter_proprank(full.proportion.long, i) 
  
  print(i)
  datalist[[it]] <- dat
  
  it <- it+1
}

eily.plot.df = do.call(rbind, datalist)
```

```{r}
ggplot(eily.plot.df, aes(x=prop, y=meandist)) + geom_point()
```

