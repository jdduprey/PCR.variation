---
title: "helen.ASV.level.var"
author: "Helen Casendino"
date: "8/04/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
```{r dependencies, include=FALSE}
library(tidyverse)
```

## Description: 
  1) Starting with triplicate PCR reads that have seriously low reads excluded, I'll get a standard deviation across PCR reps for each Hash. Hashes in different bio reps are kept separate. 
  2) Then, I'll loop through different proportion cutoffs (averaging proportions across PCR reps for each hash), each time calculating the LOGNORMAL mean of all of the standard deviations (across bio reps, etc.)


```{r read in clean triplicate data}
trip.proportion.reads <- read.csv('../data/PCR.proportions.clean.csv')
```

```{r standard deviation of each Hash}
SD.across.PCR <- function(df, PCR.col.numbers){
  df$StanDev <- NA
  PCRs.only <- df[,PCR.col.numbers]
 df$StanDev <- apply(PCRs.only, MARGIN = 1, sd)
 return(df)
}

trip.SDs <- SD.across.PCR(trip.proportion.reads, c(4:6))
```

Now, I'll do the same but with different hash rarity cutoffs. This involves:
  - ranking the hashes by average proportion across PCR reps
  - chopping some hashes
  - calculating the standard deviation of each remaining hash across PCR replicates
  - converting those standard deviation to log (because they will *most likely* be lognormally distributed) 
  - keeping track of the lognormal mean

Some things to fix with the function below:
  - should somehow check that SDs for each cutoff are lognormally distributed
  - make the function usable for duplicates as well

```{r standard deviation of each Hash with cutoff}
SDcutoffs <- function(df, cutoffs){
  
  lognormal.means <- data.frame(cutoffs = cutoffs, logmeans = rep(NA, length(cutoffs)), exclpercent =rep(NA, length(cutoffs)))
    
     meanProp.acrossPCR <- df %>% group_by(Hash) %>% summarise(meanProp.PCR = mean(c(PCR1_prop, PCR2_prop,PCR3_prop))) %>% arrange(desc(meanProp.PCR)) # to get rarity order
    
    for(i in 1:length(cutoffs)){
      sub.tib <- meanProp.acrossPCR %>% filter(meanProp.PCR > cutoffs[i]) # chop hashes below proportion cutoff
       lognormal.means[i,3] <- 1 - (length(sub.tib$Hash)/length(meanProp.acrossPCR$Hash)) # column 3 is % of UNIQUE hashes excluded
      
      PCR.tib <- df %>% filter(Hash %in% sub.tib$Hash) %>% select(!c(Hash, bio,Miseq_run)) # all PCR props corresponding to remaining hashes
      
     PCR.SD.tib <- SD.across.PCR(PCR.tib, c(1:3))
  lognormal.means[i,2]  <- exp(mean(PCR.SD.tib$StanDev) + (((sd(PCR.SD.tib$StanDev))^2)/2))
   
   print(i) # progress bar
  }
     return(lognormal.means)
}
```

```{r get output}
output<- SDcutoffs(trip.proportion.reads,seq(0, 0.00004, 0.00001))
```






```{r nesting code for later:}
#df %>% nest(data = c(sample,Hash,nReads))
```